package my;

import my.matchers.PersonMatcher;
import my.model.Person;
import org.junit.jupiter.api.Disabled;
import org.junit.jupiter.api.Test;

import java.time.LocalDate;

import static my.matchers.PersonMatcher.hasName;
import static org.hamcrest.MatcherAssert.assertThat;
import static org.hamcrest.Matchers.*;
import static org.junit.jupiter.api.Assertions.assertThrows;

public class PersonMatcherTest {

    @Test
    public void testPersonMatcher() {
        // Example usage of PersonMatcher
        //Person person = new Person("John");
        Person person = new Person("John", LocalDate.now().minusYears(30).minusDays(90));

        // Assuming you have a matcher for Person, e.g., isPersonNamed("John")
        // assertThat(person, isPersonNamed("John"));

        // If you have a custom matcher, it would look something like this:
        // assertThat(person, PersonMatcher.isPersonNamed("John"));

        // For demonstration purposes, this test currently does nothing.
        // You would replace the above comments with actual assertions.
        assertThat(person, hasName(is("John")));
        // This will check if the person's name is "John" using the hasName matcher.
        // If the name is not "John", it will throw an AssertionError.
        // The hasName matcher is a FeatureMatcher that extracts the name from the Person object
        // and checks it against the provided matcher (in this case, is("John")).
        // The FeatureMatcher will log the calls to featureValueOf, showing how it extracts the
        // feature (name) from the Person object.
    }

    @Disabled("Temporarily skipping this testâ€“needs investigation")
    @Test
    public void testPersonMatcherWithNameNegativeTest() {
        //Person person = new Person("John");
        Person person = new Person("John", LocalDate.now().minusYears(30).minusDays(90));
        // This test is expected to fail because the person's name is "John", not "Jane".
        // The hasName matcher will check if the name matches "Jane", which it does not
        // and will throw an AssertionError.
        assertThat(person, hasName(is("Jane")));
        // This will fail because the person's name is "John", not "Jane".
        // The hasName matcher will extract the name from the Person object and compare it to "Jane".
        // Since the names do not match, it will throw an AssertionError.
        // The test is designed to demonstrate the failure case of the hasName matcher.
        // If you run this test, it will fail, showing that the person's name was "John" instead of "Jane".
        // The failure message will indicate that the expected name was "Jane" but the actual name was "John".
        // This is useful for verifying that the matcher correctly identifies when the name does not match.
        // If you want to see the failure message, you can run this test in your IDE
        // or using a test runner. It will show the mismatch description generated by the hasName
        // matcher, which will indicate that the expected name was "Jane" but the actual name was "John".
    }

    // Write a negative test for the PersonMatcher for the hasName matcher
    @Test
    public void testPersonMatcherNegative() {
        // Create a Person object with a specific name
        Person person = new Person("John", LocalDate.now().minusYears(30).minusDays(90));
        // This test is expected to fail because the person's name is "John", not "Jane".
        // The hasName matcher will check if the name matches "Jane", which it does not
        // and will throw an AssertionError.
        assertThrows(AssertionError.class, () -> {
            assertThat(person, hasName(is("Jane")));
        });
        // This will fail because the person's name is "John", not "Jane".
        // The hasName matcher will extract the name from the Person object and compare it to "
        // Jane". Since the names do not match, it will throw an AssertionError.
        // The test is designed to demonstrate the failure case of the hasName matcher.
        // If you run this test, it will fail, showing that the person's name was "John" instead of "Jane".
        // The failure message will indicate that the expected name was "Jane" but the actual name was "John".
        // This is useful for verifying that the matcher correctly identifies when the name does not match.
        // If you want to see the failure message,
        // you can run this test in your IDE or using a test runner.
    }

    // Negative test: verify the exception message
    @Test
    public void testPersonMatcherExceptionMessage() {
        Person person = new Person("John", LocalDate.now().minusYears(30).minusDays(90));
        AssertionError error = org.junit.jupiter.api.Assertions.assertThrows(AssertionError.class, () -> {
            assertThat(person, hasName(is("Jane")));
        });
        // Check that the message contains the expected text
        org.junit.jupiter.api.Assertions.assertTrue(
                error.getMessage().contains("Expected: a person with name is \"Jane\""),
                "Exception message should contain expected description"
        );
        org.junit.jupiter.api.Assertions.assertTrue(
                error.getMessage().contains("name was \"John\""),
                "Exception message should contain actual value"
        );
    }

    // Test for isYouth matcher. Using allOf and greaterThanOrEqualTo, lessThanOrEqualTo
    @Test
    public void aTeenPersonShouldPasstheIsYouthTest() {
        // Create a Person object with a specific age
        Person teen = new Person("John", LocalDate.now().minusYears(15).minusDays(90));
        //System.out.println("[Test] Created person with age: " + teen.getAge());
        System.out.printf("[Test] Created person with age: %f%n", teen.getAge());
        // Check if the person is a youth (age between 18 and 30)
        //assertThat(person, hasName(is("John"))); // Ensure the name is correct
        //assertThat(person, PersonMatcher.isYouth(is(20.0))); // Assuming isYouth

        //assertThat(person, PersonMatcher.isYouth(allOf(greaterThanOrEqualTo(15), lessThanOrEqualTo(21))))); // Assuming isYouth
        //assertThat(teen, isYouth(allOf(greaterThanOrEqualTo(13), lessThan(20)))); // passes
        assertThat(teen, PersonMatcher.isYouth(allOf(greaterThanOrEqualTo(15.0), lessThan(21.0)))); // passes
        // assertThat("apple123", allOf(hasLength(greaterThan(5)), containsPattern("\\d+")));
        // matcher checks if the age is between 18 and 30
        // This will pass if the person's age is within the specified range.
        // If the age is outside the range, it will throw an AssertionError.
    }

    // Test for isYouth matcher. Using allOf and greaterThanOrEqualTo, lessThanOrEqualTo. An adult person should not pass the isYouth.
    @Test
    public void anAdultPersonShouldNotPassTheIsYouthTest() {
        // Create a Person object with a specific age
        Person adult = new Person("John", LocalDate.now().minusYears(30).minusDays(90));
        //System.out.println("[Test] Created person with age: " + adult.getAge());
        System.out.printf("[Test] Created person with age: %f%n", adult.getAge());
        // Check if the person is a youth (age between 18 and 30)
        //assertThat(person, hasName(is("John"))); // Ensure the name is correct
        //assertThat(person, PersonMatcher.isYouth(is(20.0))); // Assuming isYouth

        //assertThat(person, PersonMatcher.isYouth(allOf(greaterThanOrEqualTo(15), lessThanOrEqualTo(21))))); // Assuming isYouth
        //assertThat(adult, isYouth(allOf(greaterThanOrEqualTo(13), lessThan(20)))); // passes
        //assertThat(adult, PersonMatcher.isYouth(allOf(greaterThanOrEqualTo(15.0), lessThan(21.0)))); // passes

        AssertionError assertionError = assertThrows(AssertionError.class, () -> {
            assertThat(adult, PersonMatcher.isYouth(allOf(greaterThanOrEqualTo(18.0), lessThanOrEqualTo(30.0))));
        });
        // Print the exception message
        System.out.println("Actual exception message: " + assertionError.getMessage());

        // Verify the exception message
        org.junit.jupiter.api.Assertions.assertTrue(
                assertionError.getMessage().contains("Expected: a person with age"),
                "Exception message should contain expected description"
        );
/*        org.junit.jupiter.api.Assertions.assertTrue(
                assertionError.getMessage().contains("age was"),
                "Exception message should contain actual value"
        );*/
        // assertThat("apple123", allOf(hasLength(greaterThan(5)), containsPattern("\\d+")));
        // matcher checks if the age is between 18 and 30
        // This will pass if the person's age is within the specified range.
        // If the age is outside the range, it will throw an AssertionError.
    }
}
